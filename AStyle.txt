Кодстайл AStyle
Правила оформления кода для программ на языке C++.


Оглавление
1. Общие положения
1.1. Термины, применяемые в этом документе
1.2. Принципы кодстайла AStyle
1.3. Трактовка ООП (Объектно-Ориентированного Программирования) в кодстайле AStyle
1.4. Правила Идеальной Архитектуры
2. Файлы проекта
2.1. Организация файлов проекта
2.2. #include
2.3. #pragma once и header guard
2.4. Формат текста исходных файлов
3. Имена
3.1. Общие правила
3.2. Локальные имена
3.3. Не-локальные имена
3.4. Аббревиатуры
3.5. Префиксы
3.6. Метки
3.7. Префиксы принадлежности
3.8. Имена файлов, каталогов и фильтров (виртуальных каталогов)
3.9. Имена макросов
4. Структура кода
4.1. Описание класса
4.2. Конструктор
4.3. Функции класса (методы)
4.4. Глобальные функции
4.5. Вложенные типы
4.6. Предварительное объявление (Forward declaration)
4.7. Пространство имён (namespace)
4.8. Inline functions
4.9. Наследование
4.10. Друзья
4.11. Объявление функции в заголовочном файле
4.12. Методы в cpp-файле
4.13. Инициализация статических членов класса
4.14. Объявление подобных переменных и констант
4.15. Описание статических переменных в исходном файле
5. Переменные и параметры
5.1. Передача параметров
5.2. Локальные переменные
5.3. Унифицированный порядок параметров
5.4. Возврат результата функции через параметры
5.5. Результат вызова функции как параметра
5.6. Параметры функции по умолчанию
5.7. Локальные статические переменные и константы
5.8. Объявление функции в одной строке
6. Комментарии
6.1. Формат комментариев
6.2. Комментирование нетривиальной логики
6.3. Длинный разделитель
6.4. Однострочные комментарии
6.5. Комментарий области видимости
6.6. Описание функции
6.7. Специальные комментарии
6.8. // UNO
6.9. // No break!
7. Форматирование кода
7.1. Выравнивание пробельными (пустыми) строками
7.1.1. Выравнивание в операторе switch / case
7.1.2. Выравнивание логических секций кода
7.1.3. Пробельная строка перед оператором return
7.2. Выравнивание пробелами
7.2.1. Пробелы после одинаковых скобок
7.2.2. Выравнивание кода и данных
7.3. Фигурные скобки
7.4. Обращение к членам объекта
7.5. Завершающие пробелы
7.6. Один пробел как разделитель
7.7. Перенос длинных условий
7.8. Код в строке с case
7.9. Размещение else и if
7.10. Скобки для оператора return
7.11. & и *
8. Типы
8.1. Стандартные типы
8.2. RTTI (Run-Time Type Information)
8.3. Преобразования типов
8.4. Оператор преобразования типа
8.5. auto
8.6. Алиасинг типов
8.7. Перечисления (enum)
8.8. Использование указателей в контейнерах
9. Инициализация данных
9.1. Инициализация переменных встроенного типа
9.2. Инициализация переменных сложного типа
9.3. Инициализация фигурными скобками
9.4. Инициализация указателя
9.5. Инициализация всех не-статических членов данных встроенного типа
9.6. Перенос длинной строки списка инициализации конструктора
10. Проверка значений
10.1. Проверка булевых значений
10.2. Проверка всех остальных типов
10.3. Двойное отрицание
10.4. Возврат отсутствия объекта
10.5. Тернарное условие
10.6. Развёрнутые условия вместо компактных
11. Особенности C++
11.1. Использование this
11.2. Оператор goto
11.3. Макросы
11.4. Исключения
11.5. Шаблоны
12. Особенности новых стандартов (C++11 и старше)
12.1. Использование нововведений в C++
12.2. range-based for
12.3. constexpr
12.4. Лямбды
13. Использование стандартной библиотеки
13.1. Стандартные потоки
13.2. Контейнеры стандартной библиотеки
13.3. Алгоритмы стандартной библиотеки
14. Прочие правила
14.1. Традиционные паттерны
14.2. Умные указатели
14.3. Сторонние библиотеки
14.4. Ассерты
14.5. Сериализация



1. Общие положения

1.1. Термины, применяемые в этом документе:
- Кодстайл (от англ. codestyle - стиль кода) - термин, которым обозначен этот документ, а так же другой подобный документ.
- Стабильность сборки - характеристика, описывающая результат сборки проекта.
-- Ошибки, вызванные отсутствием необходимых файлов либо ссылкой на сущности, отсутствующие в доступном наборе файлов означают, что сборка нестабильна.
-- Периодическое возникновение и исчезновение таких ошибок также означает, что сборка нестабильна.


1.2. Принципы кодстайла AStyle
- Код, к которому применяется данный стиль, должен реализовывать методы ООП (Объектно-Ориентированного Программирования) в трактовке кодстайла AStyle.
- Целевая аудитория, для которой пишется код - начинающий разработчик (джуниор-девелопер), который уже может писать программы, используя простые алгоритмы и паттерны.
- Используется ограниченное подмножество возможностей языка C++ для того, чтобы упростить исходный код.
- Код должен читаться не только в среде программирования, но и в дополнительных инструментах (программах мерджа файлов, системах для код-ревью, текстовой документации).
- Главная ценность исходного кода - стоимость сопровождения, выраженная во времени, затраченном на разработку и последующее исправление исходного кода.
-- Скорость чтения кода и его сложность имеет прямую зависимость - чем проще код, тем быстрее он читается (и хотя скорость чтения кода является индивидуальной характеристикой,
   в среднем, начинающий разработчик читает код гораздо медленнее, чем опытный за счёт того, что многие сложные паттерны начинающий разработчик не узнаёт, а анализирует).
-- Код имеет 4 характеристики, по которым оценивается его качество:
--- 1. Скорость чтения кода
--- 2. Скорость выполнения программы
--- 3. Потребляемые программой ресурсы
--- 4. Компактность кода
-- По умолчанию, для проекта на этапе реализации, скорость чтения кода является главной характеристикой исходного кода, т.е. более приоритетной, чем все остальные.
-- Приоритетность скорости чтения кода следует понизить только в тех случаях, когда другие характеристики не соответствуют требованиям программы.
- Код написан авторами, не враждебными по отношению к другим авторам, поэтому не следует изолировать всё, что только можно, защищать константами все параметры и функции и т.п.
  Наоборот, следует стремиться к минимальному использованию слова const (применять только там, где его отсутствие меняет смысл кода), не использовать интерфейсы,
  если можно обойтись без них и избегать паттернов, изолирующих код.
- Код должен быть оптимизирован:
-- Для быстрого чтения и поиска
-- Для отладки отладчиком, а не логированием
- Рефакторинг кода должен быть естественным решением при любом изменении условия постановки задачи, исправлении ошибки или обнаружении более эффективного решения.
-- Рефакторинг интерпретируется как улучшение кода более ценное, чем любое другое исправление, поэтому рефакторинг следует применять каждый раз, когда это может повысить ценность
   исходного кода.
- Для кода допускается промежуточное состояние, в котором кодстайл частично нарушается, и такой код считается нуждающимся в рефакторинге
-- Такой рефакторинг становится приоритетной задачей и разработчики должны стремиться исправить такой код как можно быстрее, чтобы привести его в соответствие кодстайлу AStyle.
-- Не следует приступать к разработке новой функциональности в коде с нарушенным кодстайлом.
-- Разработка функциональности, исправление ошибок либо рефакторинг считается законченным только когда код приведен в соответствие с кодстайлом AStyle.
- "Пределом экрана" обозначается строка длиной 180 символов.
-- Команда разработчиков может принять другую длину, если это повысит эффективность работы для всей команды.
- Вертикальное пространство исходного кода более ценно, чем горизонтальное, поэтому допустимы и приветствуются строки, выходящие за пределы экрана.
- Повторение вызова метода рассматривается как приемлемое повторное использование кода, в то время как повторение выражений (например, математических вычислений) либо повторение
  множества последовательных строк кода уже трактуется как "дубликат" кода, который требует рефакторинга.


1.3. Трактовка ООП (Объектно-Ориентированного Программирования) в кодстайле AStyle
- Все логические сущности, имеющие свойства и методы взаимодействия с этими свойствами, должны быть описаны отдельными классами
-- Методы реализуются функциями класса
-- Свойства реализуются членами данных (переменными и константами), но при необходимости могут иметь в своём классе отдельные функции для установки и чтения значений
   (сеттеры и геттеры)
-- Сущности, имеющие только данные и деструктор с конструкторами, являются вырожденным случаем класса и могут быть реализованы либо в виде структуры, либо в виде класса
   (на усмотрение автора)
- Глобальные функции и данные недопустимы (глобальные - это те, которые не принадлежат классу или структуре), за исключением единственной глобальной функции main,
  либо её эквивалента
-- Альтернативой глобальным функциям и данным являются статические члены классов
- Экземпляр класса либо структуры называется объектом
- Объектно-ориентированное программирования означает, что все сущности программы являются объектами, взаимодействующими между собой через методы этих объектов.
-- Таким образом, любой метод либо элемент данных должен принадлежать какому-либо объекту и поэтому глобальные (либо свободные) методы и данные не уместны в контексте ООП
- 3 принципа ООП:
-- Инкапсуляция - это группировка данных (переменных, констант) и функций внутри одной сущности (класса или структуры).
--- Инкапсуляция - это НЕ сокрытие данных или кода.
--- Все методы, которые могут вызываться пользователями класса должны быть публичными
--- Все данные, доступ к которым не требует обработки, должны быть публичными
---- Сеттеры и геттеры должны использоваться только при нетривиальном доступе (например, проверке диапазона)
-- Наследование - это объединение функциональности и данных нескольких классов в один, при этом:
--- Новый класс, к которому присоединяются другие классы, называется "производным".
--- Классы, которые присоединяются к новому классу, называются базовыми.
--- Новый класс "A" как сущность относится к каждому базовому "B" как "A - это B".
--- Новый класс:
---- Может скрыть часть данных и функций базовых классов, используя защищённые и приватные секции
---- Может реализовать виртуальные функции базовых классов
-- Полиморфизм - это множество реализаций одной сущности, бывает двух типов:
--- Статический, реализованный в виде шаблонов и перегрузок функций - позволяет использовать множество одноимённых функций либо классов (отличающихся шаблонными параметрами)
--- Динамический, реализованный механизмом виртуальных функций - позволяет объекту одного типа (базового) вести себя как объект другого типа (производного)


1.4. Правила Идеальной Архитектуры
1. Главное правило Идеальной Архитектуры - выносить все повторения в отдельную сущность:
- Одинаковый или похожий код выносится в функцию
- Одинаковый или похожий набор данных выносится в структуру либо класс
2. Данные и функции, оперирующие ими, группируются в отдельный класс, при этом:
- Класс описывает некую "сущность"
- Функции (т.е. методы) класса - трактуются как "действия" этой сущности
- Данные рассматриваются как "свойства" сущности
3. Класс представляется как "прозрачный ящик" (в противоположность "чёрному ящику"):
- Не делать методы доступа (сеттеры и геттеры) для переменных, которые могут свободно меняться
- По возможности, не использовать классы-интерфейсы
- Класс должен содержать в себе методы для тестирования и проверки (не делать отдельных сущностей)



2. Файлы проекта

2.1. Организация файлов проекта
Все файлы, принадлежащие проекту, хранятся на диске в одном каталоге. Разбиение файлов на каталоги (на виртуальные каталоги или фильтры) и представление их в виде иерархии
производится в среде разработки.
Файлы, которые можно вынести в отдельную библиотеку с целью повторного использования в другом проекте нужно вынести в отдельный каталог на диске.
Расположение кода в файлах зависит от способа представления кода:
1. Обычный (большой класс (более 200 строк), имеющий реализацию методов)
2. Смешанный (множество небольших классов в одном, количество строк - любое)
3. Шаблонный (класс с методами)
4. Без реализации (интерфейсы, перечисления, шаблонные типы, макросы и данные)

Для "обычного" и "смешанного" представления нужно использовать одноимённую пару *.cpp / *.h файлов.
Для "шаблонного" и "без реализации" используется только заголовочный *.h-файл.
Почему:
1. В заголовочных файлах уместно размещать объявления классов и типов
2. Шаблонные классы, представленные в паре *.cpp / *.h файлов обычно привносят много неожиданных ошибок и вносят риск дестабилизации в проект, поэтому их целиком следует
   располагать в h-файле.

Все исходные файлы проекта C++ должны состоять только из двух типов файлов - *.cpp и *.h. Остальные файлы интерпретируются как ресурсы и не должны участвовать в компиляции кода.
Скрипты и сторонние инструменты должны подготовить свои результаты либо до (стадия pre-build), либо после (стадия post-build) компиляции проекта C++.
Все исходные файлы должны образовывать логическую иерархию включения, реализованную директивами #include.
Все подключаемые через #include файлы должны подключаться в заголовочном файле, за исключением заголовочного файла, парного *.cpp-файлу.
Типичный исходный *.cpp-файл должен подключать через директиву #include только один заголовочный файл - свой парный заголовочный файл.
Типичный заголовочный *.h-файл содержит подключения нескольких заголовочных файлов, от которых он зависит.
Все подключения заголовочных файлов должны быть в начале файла, до того, как начнутся определения других типов.
Если подключаемый заголовочный файл уже подключается ранее, через подключение другого - нужно использовать только одно, более раннее подключение.
Подключение множества заголовочных файлов в *.cpp-файле допустимы в двух случаях:
1. Когда нужно инкапсулировать подключаемые сущности внутри текущего *.cpp-файла для того, чтобы больше нигде в проекте эти сущности не фигурировали
2. При разработке кросс-платформенных приложений, либо других проектов, требующих подключения различных заголовочных файлов в зависимости от условий (т.е. при подключениях под #ifdef)

Никогда не использовать precompiled headers и подключение stdafx.h

Множество типов, используемых совместно (например, класс и перечисления, которые он использует, или классы одной иерархии) могут содержаться в одной паре исходных файлов *.cpp и *.h.
Не следует спамить файлами, создавая отдельный файл для каждого типа, например, для перечисления.
Выносить сущности в отдельную пару файлов следует тогда, когда нужно только подключение такой сущности без остальных, присутствующих в том же файле.

Все сущности проекта должны иметь иерархическую зависимость, и такую зависимость мы выражаем через иерархию подключаемых файлов.
Почему:
1. Директива #include добавляет в исходный файл всё содержимое указанного файла, поэтому не стоит подключать множество заголовочных файлов в *.cpp - файле, если это можно сделать
   одной строкой.
2. Подключая заголовочный файл, мы должны получить полный набор информации об объявленных сущностях. Если же после подключения такого файла требуются дополнительные подключения
   или предварительные объявления (forward declarations), значит заголовочный файл создан не правильно.


2.2. #include
Директивой #include можно подключать только заголовочные файлы. В случае, когда нужно подключить внешний текст внутри программы следует:
1. Либо оформить этот текст как заголовочный файл и подключить его (если текст меняется редко)
2. Либо использовать генератор контента (программу, скрипт), которая экспортирует / сериализует данные в виде заголовочного файла (если текст меняется часто)
Не подключать *.cpp-файлы директивой #include.
Почему:
1. Когда структура проекта статична (нет динамических подключений файлов) риск утратить стабильность сборки значительно меньше, чем в проектах с динамическим контентом.
2. Такой подход сводит количество возможных типов подключаемых сущностей к двум - *.cpp и *.h файлы.


2.3. #pragma once и header guard
Первой строкой кода каждого заголовочного файла должна быть следующая строка:
#pragma once
Альтернатива этому - header guard, - не используется.
Почему:
1. #pragma once - это одна строка кода, одинаковая для всех файлов
2. header guard - это макрос, который может быть случайно или специально переопределён, что вносит риск нестабильности сборки
3. header guard - это 3 строки кода вида:
#ifndef HEADERFILE_H
#define HEADERFILE_H
#endif // HEADERFILE_H
уникальных для каждого файла, но, иногда, в результате копипаста, эти константы - дублируются.


2.4. Формат текста исходных файлов
Все исходные файлы (*.cpp и *.h), должны сохраняться в формате UTF8 (UTF-8 with signature, Codepage 65001). Это позволит комментариям и контенту на не-английском языке
адекватно отображаться у всех участников проекта.



3. Имена
Термины:
- Локальное имя - идентификатор, объявленных внутри функции: параметр функции, переменная, константа или метка.
- Не-локальное имя - все остальные идентификаторы


3.1. Общие правила
Все имена типов, функций, констант и переменных, состоящие из нескольких слов, разделяются символом подчёркивания.
Число считается отдельным словом.
Подчёркиванием не может начинаться либо заканчиваться имя (за исключением метки, которая должна начинаться с подчёркивания).
Допускается использование двойного подчёркивания для визуального выделения групп слов в имени.
Имя идентификатора трактуется, как состоящее из множества слов.
Например: Some_Function_Name(), local_variable, Parse_XML_Tag(), Parse_XML__Get_Next_Tag_Name()
Имена с двойным подчёркиванием трактуются как временные, для которых нужен последующий рефакторинг с вынесением подмножества имён в отдельную сущность.


3.2. Локальные имена
Все слова в локальных именах начинаются со строчной буквы, т.е. не заглавной.


3.3. Не-локальные имена
Для всех остальных (не-локальных) имён все слова начинаются с заглавной буквы.
Таким образом, все типы, члены класса и структуры имеют имена, состоящие из слов с заглавными буквами.


3.4. Аббревиатуры
3.4.1. Для локальных имён аббревиатуры пишутся в нижнем регистре, т.е. строчными символами.
Например, xml_tag_name, cctv_recorder, http_request.


3.4.2. Для не-локальных имён аббревиатуры пишутся полностью в верхнем регистре, т.е. заглавными символами.
Например, Convert_XML_To_JSON(), HTTP_Packet.


3.5. Префиксы
Префикс имени предназначен для облегчения идентификации имени.

3.5.1. Префикс - это 1 либо 2 символа, предваряющих имя типа, соединяющегося с именем непосредственно, т.е. без промежуточного символа подчёркивания.

3.5.2. Все классы имеют префиксом английскую заглавную букву "A"
Например, ARect, AHTTP_Packet, AActive_Listener.

3.5.2.1. Класс, объект которого должен существовать в единственном экземпляре, имеет префикс "As", где "s" означает "single".
Например, AsConfig, AsNetwork_Manager.

3.5.3. Все структуры (struct) имеют префиксом английскую заглавную букву "S"
Например, SPoint, SBook_Description.

3.5.3.1. Для структуры, экземпляр которой должен существовать в единственном числе, не предусмотрен двойной префикс.

3.5.4. Все перечисления (enum) имеют префиксом английскую заглавную букву "E"
Например, EJob, ESymbol_Type, ECar_Moving_State.

3.5.5. Все объединения (union) имеют префиксом английскую заглавную букву "U"
Например, UFile_Time.


3.6. Метки
Метка является локальным именем.
Первым символом метка должен быть символ подчёркивания.
Например, _cleanup, _error_exit.


3.7. Префиксы принадлежности
Не использовать отдельные префиксы для описания принадлежности имени к какому-либо способу доступа или области видимости.
Например, префикс "m_" для маркировки членов-данных класса не используется.


3.8. Имена файлов, каталогов и фильтров (виртуальных каталогов)
Для таких имён используется синтаксис не-локальных имён. Например, Network_Manager.cpp, HTTP_Packet.h


3.9. Имена макросов
Для макросов все символы должны быть в верхнем регистре, а слова разделяются символом подчёркивания.
Например: DEBUG, _USE_MATH_DEFINES
Не следует определять новые макросы в проекте, допустимо только использовать макросы, определённые в подключаемых библиотеках.
Единственное допустимое применение макросов - условная компиляция кода для кросс-платформенных проектов.



4. Структура кода

4.1. Описание класса
Каждая секция класса должна объявляться в классе только один раз в следующем порядке: public, protected, private
Члены каждой секции условно делятся на функции и данные, а так же на статические и простые (т.е. не-статические) члены.
Все члены каждой секции должны быть объявлены подсекциями в следующем порядке:
1. Деструктор и конструкторы
2. Виртуальные методы
3. Операторы
4. Не-статические методы
5. Не-статические данные
6. Статические методы
7. Статические данные

Каждая пара смежных подсекций должна быть разделена пробельной строкой (т.е. все подсекции разделены пробельными строками).
В случае, когда подсекция состоит из групп по несколько строк, схожих по смыслу, такие группы желательно разделить пробельными строками и предварить соответствующим комментарием.
Каждый метод должен быть объявлен в одной строке (вместе со своим возвращаемым типом и всеми параметрами).
В одной строке можно объявлять множество переменных либо констант только одного типа.

Класс должен быть полностью описан в заголовочном файле (*.h-файле). Не следует размещать описание классов в исходном файле (*.cpp-файле).
Код всех методов класса должен быть размещён в исходном файле (*.cpp-файле).
Размещение кода в заголовочном файле допускается лишь как временная мера, которая требует последующего рефакторинга.

Код шаблонного класса должен быть полностью размещён в заголовочном файле, причём сначала следует добавить описание класса, а ниже - реализацию методов
(т.е. даже для шаблонов не реализовывать методы в объявлении класса).


4.2. Конструктор
Должен инициализировать все члены данных в списке инициализации, даже если эти члены будут переинициализированы в теле конструктора.
Все указатели, кроме константных строк, следует обнулять в списке инициализации.
Почему: при досрочном завершении конструктора все члены класса окажутся проинициализированы, что обеспечит корректный набор данных для деструктора.


4.3. Функции класса (методы)
Функция должна реализовывать одну логику (т.е. один алгоритм, оперирующий одним набором сущностей).
Если таких алгоритмов несколько либо один алгоритм применяется к разному набору сущностей, такую функцию следует:
- Либо разделить на несколько меньших (т.е. выполнить рефакторинг), если такое разделение не ухудшит текущую главную характеристику кода (например, если такой является
скорость выполнения программы, то разделение на отдельные функции может замедлить код из-за передачи параметров, выполнения пролога и эпилога функции, инициализации переменных и,
таким образом, на подходит)
- Либо написать комментарий к каждой секции, оперирующей своей логикой.


4.4. Глобальные функции
В программе разрешена только одна глобальная функция - main() либо её эквивалент для данного проекта.
В случае, когда нужна глобальная функциональность, следует использовать статические методы класса.


4.5. Вложенные типы
По возможности, старайтесь вообще не использовать вложенные типы (т.е. типы, объявленные внутри класса или структуры).
Почему:
1. При сопровождении программы может возникнуть ситуация, когда нужен тип, который уже объявлен вложенным внутри другого типа. В таком случае приходится:
1.1. Либо создавать дубликат типа, чтобы не рефакторить отлаженную часть кода (плохое архитектурное решение)
1.2. Либо рефакторить, вынося тип, рискуя при этом нарушить стабильность кода (дорогое решение, требует регрессионного тестирования)
2. Встроенные типы плохо читаются и, в общем случае, имеют громоздкий синтаксис (за счёт указания множества типов (пути) в имени)


4.6. Предварительное объявление (Forward declaration)
Все типы должны быть доступны через #include соответствующего заголовочного файла.
Следует избегать использования предварительных объявлений:
- Наличие таких объявлений в коде допустимо, но трактуется как временное решение, требующее рефакторинга
- Следует использовать такие объявления только для предотвращения циклических зависимостей.

Почему:
1. Тип, объявленный предварительно, сложно найти при чтении кода; среда разработки часто не может правильно найти такой тип в проекте
2. Подключение заголовочного файла с предварительно объявленными типами внутри не подключает определения этих типов
3. Компилятор может не скомпилировать изменённый проект, генерируя ошибки, требующие углублённого анализа кода
4. Запрет на предварительное объявление вынуждает программиста развивать альтернативное решение - строить правильную иерархию заголовочных файлов


4.7. Пространство имён (namespace)
Мы не используем неймспейсы.
Попытка определить сущность с именем, которое уже используется в проекте, говорит не о том, что нужно использовать неймспейсы, а о том, что нужно использовать другое имя.
Все имена сущностей должны быть уникальными.
Почему: неймспейсы - это альтернатива классам, поощряющая программистов использовать глобальные функции и переменные. Наличие такой альтернативы порождает конкурентные решения
(сопряжение классов и неймспейсов), которые могут стать сложными в сопровождении.


4.8. Inline functions
Мы не помечаем функции как inline.
Только в редких случаях, для ускорения программы, собранной в режиме отладки, мы используем __forceinline.
Почему: мы полагаемся на оптимизацию современных компиляторов, использующих нетривиальную логику для реализации функции как inline.


4.9. Наследование
Всегда - только публичное.
Не наследовать структуры. В случае, когда это необходимо - наследовать, преобразовав структуры в классы.
Не использовать виртуальные базовые классы, вместо этого следует отрефакторить код так, чтобы необходимость в виртуальном наследовании отпала.


4.10. Друзья
Никогда не использовать friend, это нарушает инкапсуляцию класса, т.к. friend-функция или класс, не являясь членом класса, имеет доступ к членам в секциях protected и private.


4.11. Объявление функции в заголовочном файле должно полностью совпадать с определением функции в исходном файле (за исключением имени класса, которое не должно присутствовать
в объявлении класса. Например:
- в заголовочном файле:
class AMy_Class
{
   ...
   void Method(int param_1, int param_2, int param_3);
}

- в исходном файле:
void AMy_Class::Method(int param_1, int param_2, int param_3);

Несмотря на то, что C++ позволяет в объявлении функции указывать только типы параметров (без имени), либо другое имя, следует всегда использовать точно такое же имя как для
объявления в заголовочном файле, так и для определения в исходном. Например:
void Method(int, int, int);  // Плохо! Для понимания, где какой параметр, нужно смотреть в исходный файл
void Method(int p1, int p2, int param_3);  // Плохо! Возможна путаница с перегруженными функциями, имеющими подобные параметры; для уточнения всё равно надо смотреть в исходный файл
void Method(int param_1, int param_2, int param_3);  // Хорошо, объявление метода совпадает с его определением в исходном файле (за исключением имени класса)

Возвращаемый тип, имя метода и все его параметры всегда должны быть представлены в одной строке, даже если строка выходит за пределы экрана.


4.12. Методы в cpp-файле определяются в том же порядке, в каком они указаны в заголовочном h-файле.
Если в результате изменений кода порядок функций в объявлении класса изменился, следует отразить этот порядок и исходном cpp-файле, перенеся методы.


4.13. Инициализация статических членов класса размещается перед объявлением первого метода. Например:
// AClass
//------------------------------------------------------------------------------------------------------------
int AClass::Static_Variable = 15;
double AClass::Static_Const = 1.2345;
//------------------------------------------------------------------------------------------------------------
AClass::~AClass()
{
}
//------------------------------------------------------------------------------------------------------------


4.14. Объявление подобных переменных и констант
При объявлении подобных переменных и констант можем размещать в одной строке множество имён, если они логически сгруппированы. Например:
int X, Y;
int Width, Height;


4.15. Описание статических переменных в исходном файле
При описании статических переменных в исходном файле каждую описываем в отдельной строке. Например:
float AClass::Min_Pos_X = 0;
float AClass::Min_Pos_Y = 0;
float AClass::Min_Pos_Z = 0;



5. Переменные и параметры

5.1. Передача параметров
При написании кода, мы подразумеваем, что автор любой вызываемой функции не намеревается навредить нашей программе, и, следовательно, мы не используем ограничения и запреты там,
где этого можно и не делать.
Следует использовать const для параметров, только если это часть типа, либо функции запрещено менять значение такого параметра. Во всех остальных случаях const не используется.
Например:
bool AClass::Get_First_Symbol_Pos(const char *sub_str, int sub_str_len, char symbol, int &first_pos);
Параметры в этом примере:
const char *sub_str - используем const, т.к. это является частью типа "const char *"
int sub_str_len - не используем const, т.к. изменение этого значения не подразумевается; функция и так может обратиться за пределы строки, и константность этого параметра ничего не предотвратит
char symbol - так же не константа, т.к. изменение искомого символа просто исказит ожидаемый результат; функция и так может искать любой другой символ вместо указанного
int &first_pos - не константа, т.к. это используется как возвращаемый параметр, если функция вернёт true.

При передаче параметров все параметры пишут в одной строке, а в случае, когда длина строки превышает предел экрана, можно (но не обязательно) продолжить перечисление параметров
на следующей строке.
Почему: при поиске по коду в первую очередь важно имя функции, и уже во вторую - перечень её параметров:


5.2. Локальные переменные
Переменные инициализируются значением только при необходимости иметь такое значение перед первым использованием переменной. Другими словами, не следует инициализировать переменную,
если она при первом использовании будет перезаписана.
Все переменные, не требующие инициализации, а также константы должны быть описаны в начале функции.
Почему:
1. Позволяет оформить переменные отдельной секцией, что упрощает их поиск по коду (вы всегда ожидаете найти переменные в начале функции)
2. Упрощает повторное использование переменных
При соблюдении кодстайла AStyle, функция, в которой объявляются переменные после первой строки кода, является характерным (но не обязательным) признаком того, что данная функция
нуждается в рефакторинге.
Причинами размещения переменных внутри тела функции могут быть:
- Несколько "логик", реализованных внутри одной функции (что следует отрефакторить разделением на под-функции)
- "Костыли" - точечные исправления алгоритмов (что следует отрефакторить, переписав алгоритм)
- Особенности алгоритма, при которых объявление переменных внутри тела функции можно считать эффективным и правильным решением (редкие, но вполне возможные случаи при использовании
  кодстайла AStyle)
Повторное использование переменных позволяет экономить ресурсы и повышает читабельность кода за счёт уменьшения количества сущностей.
Повторно использовать следует только те переменные, которые имеют один и тот же смысл, например, индекс цикла.
Порядок объявления переменных:
1. Переменные цикла,
2. Все переменные и константы встроенного типа,
3. Указатели,
4. Экземпляры структур и классов
5. Массивы
Массивы следует объявлять последними, т.к. случайное превышение предела последнего массива перетрёт мусор в памяти, а не значения других локальных переменных.
При объявлении переменных группируем их по функциональным группам. Неочевидные имена подписываем комментарием.
Например:
void AUnit::Advance(double step)
{
	double x, y;
	double distance;
	double overlap;  // Размер, на который был превышен диапазон
}

Игнорируем выравнивание локальных переменных в памяти (подразумевая, что памяти стека хватит для функции), кроме задач, где экономия и/или оптимизация измеримо влияет
на главную характеристику кода.

Переменные-объекты, являющиеся экземплярами структур и классов, следует инициализировать перед первым использованием.

class APos
{
public:
	APos(int x, int y);

	int X, Y;
};

void AClass::Some_Function(bool can_run)
{
	APos one_pos(0, 1);  // Не правильная инициализация - переменная one_pos может не понадобится

	if (! can_run)
		return;

	//APos one_pos(0, 1);  // Здесь следовало инициализировать эту переменную
	APos another_pos(2, 3);  // Правильная инициализация - переменная another_pos точно будет использована

	Handle_Pos(one_pos);
	Handle_Pos(another_pos);
}


5.3. Унифицированный порядок параметров
Если несколько функций используют похожий набор параметров, следует эти параметры в разных функциях перечислять в одном и том же порядке.
Предположим, если есть функция Set_Point(int x, int y), то такой же порядок (сначала "x", потом "y") мы используем в любой другой, где они означают координаты, например:
Fill_Area(unsigned char *buf, ARect &area, int x, int y) );
Это позволит при чтении кода автоматически оперировать термином "int x, int y" как единым целым, и, к тому же, снизит вероятность внести ошибку, перепутав координаты.
Такую же последовательность следует использовать и для членов данных классов и структур. Например:
class ARect
{
public:
	int X, Y;
	int Width, Height;
};


5.4. Возврат результата функции через параметры
Мы широко используем функции, возвращающие множество значений.
Возврат через параметры следует использовать:
1. Когда нужно вернуть множество параметров
Например:
void Get_Coordinates(int &x, int &y);
2. Когда нужно вернуть значение сложного типа (т.е. не встроенного типа), чтобы не создавать лишний раз объекты.
Например, для возврата значения типа ARect используем функцию вида:
void Get_Rect(ARect &rect)
а не
ARect Get_Rect()
3. Когда нужно вернуть несколько результатов с разным смыслом.
Например, итератор, возвращающий значение очередного ARect:
bool AClass::Get_Next_Rect(int &index, ARect &rect)
{
	if (index < 0 || index >= Max_Rect_Count)
		return false;

	rect = All_Rects[index++];  // Вернули 2 значения - заполнили rect и увеличили index

	return true;  // Вернули 3-е значение, означающее возможность продолжать
}
Использование такой функции:
int index = 0;
ARect rect;

while (Get_Next_Rect(index, rect) )
	Do_Something_With_Rect(rect);

Не следует использовать структуры-обёртки для передачи и возврата множества параметров, потому что множество параметров и метод, работающий с ними, это главный признак объединения
данных и метода в отдельный класс.
Другими словами, сторонний метод, оперирующий членами структуры либо класса, нарушает его инкапсуляцию, что противоречит принципам ООП кодстайла AStyle.


5.5. Результат вызова функции как параметра
При вызове функции следует избегать передавать в качестве параметра результат вызова другой функции, вместо этого следует использовать промежуточную переменную.
Почему:
1. Компилятор и так неявно создаст временную переменную, принимающую результат промежуточного вызова, так что такое сокращение кода не повышает эффективность программы.
2. Промежуточное значение:
2.1. Облегчает отладку (можно посмотреть его до вызова функции)
2.2. Ускоряет отладку, т.к. при входе в вызываемую функцию не происходит вход в промежуточную функцию

Например:
1. Плохой вариант:
Some_Function(param_1, Calculate_Param_2() );

2. Правильный вариант:
int param_2 = Calculate_Param_2();

Some_Function(param_1, param_2);


5.6. Параметры функции по умолчанию
Используйте параметры функции по умолчанию, если это позволит избежать указывать параметр лишний раз.
Например:
void Draw_Line(HDC hdc, int x, int y, int width = 2);  // Уместно для решения, в котором почти все линии, кроме некоторых, рисуются толщиной, равной 2

В качестве значений допустимо использовать только константы.
void Wrong_Function(int param_1, int param_2 = other_variable++);  // Вносит неопределённость в код, т.к. глядя на вызов этой функции будет не понятно, чему будет равен второй параметр


5.7. Локальные статические переменные и константы
Можно использовать такие переменные и константы только при отладке проекта, т.к. это иногда позволяет эффективно решать задачи, однако после отладки их следует удалять, либо
переносить в объявление класса, чтобы программист, читающий программу, смог обнаружить описание всех статических переменных и констант в объявлении класса в заголовочном файле.


5.8. Объявление функции в одной строке
При вызове функции возвращаемое значение, имя функции и все её аргументы располагаются на одной строке. В случае, если строка не помещается на экране, можно продолжить
последовательность аргументов на следующей строке.
Например:
int value_1 = Function(param_1, param_2, param_3);  // Правильно

int value_2 = Function(param_1,
                       param_2,
                       param_3);  // Не правильно, т.к. код занимает слишком много места



6. Комментарии

6.1. Формат комментариев
Язык комментариев может быть любым, предпочитайте язык, на котором вы думаете и общаетесь внутри команды.
В случае, когда языков больше одного, например, если проект разрабатывается интернациональной командой, используйте английский.
Следует всегда использовать однострочные комментарии (множество последовательных строк также оформляется однострочными комментариями), за исключением двух случаев,
когда можно использовать блок комментариев /* */:
- Если нужно разместить фрагмент текстовой документации внутри кода
- Если нужно временно закомментировать часть кода


6.2. Комментирование нетривиальной логики
Каждая нетривиальная логика должна быть описана комментарием:
- Когда используемые имена не описывают процессов, выраженных в коде
- Когда используемые имена можно трактовать различными способами
- Для сложных формул

Например:
1. Загадочное имя
1.1. Оригинальный код:
	Fn(13);

1.2. Улучшенный код:
	Fn(13);  // Переход на 13-й уровень

2. Не хватает информации:
2.1. Оригинальный код:
	Notify(caller);

   Понятно, что Notify() должен что-то сообщить caller-у, но что? И зачем?

2.2. Улучшенный код:
	Notify(caller);  // Сообщить caller-у, что он может уже не ждать результат, т.к. лимит времени превышен

3. Формула, которую может распознать не каждый:
3.1. Оригинальный код:
	distance = sqrt(dx * dx + dy * dy);

3.2. Улучшенный код:
	distance = sqrt(dx * dx + dy * dy);  // Вычисляем длину вектора


6.3. Длинный разделитель
Все методы внутри *.cpp-файла должны быть разделены "длинным разделителем" - строкой с комментарием длиной 111 символов, состоящим из двух символов '/' и 109 символов "минус":
//------------------------------------------------------------------------------------------------------------
Например:
//------------------------------------------------------------------------------------------------------------
void AClass::Method_1()
{
}
//------------------------------------------------------------------------------------------------------------
void AClass::Method_2()
{
}
//------------------------------------------------------------------------------------------------------------

Длинным разделителем должны быть разделены все описания типов внутри одного файла.
Например:
//------------------------------------------------------------------------------------------------------------
enum ESymbol_Type
{
};
//------------------------------------------------------------------------------------------------------------
class ASpecial_Symbol
{
};
//------------------------------------------------------------------------------------------------------------

Длинный разделитель должен быть:
- Перед первым и после последнего определения функции
- Перед первым и после последнего объявления типа

Если в одном cpp-файле находится определения функций нескольких классов, то:
- Все функции одного класса должны быть определены одним блоком, последовательно, в том же порядке, в котором они указаны объявлены в типе, и разделены длинными разделителями
- Перед каждым блоком следует указать однострочный комментарий с названием класса в формате: два слеша '/', пробел, имя типа
- Каждую пару смежных блоков следует разделить блоком из 4-х пустых строк

Например:
// AOne_Class
//------------------------------------------------------------------------------------------------------------
void AOne_Class::Method()
{
}
//------------------------------------------------------------------------------------------------------------




// AAnother_Class
//------------------------------------------------------------------------------------------------------------
void AAnother_Class::Method()
{
}
//------------------------------------------------------------------------------------------------------------


6.4. Однострочные комментарии:
- Имеет формат: два слеша '/', пробел, текст комментария, начинающийся с заглавного символа, либо со строчного, если данная строка продолжает предыдущий комментарий
- Если занимают всю строку, то должны начинаться с тем же отступом, что и предыдущая строка
- Если заканчивает строку кода (кроме случая комментария области видимости), то должен отступать от последнего символа на два пробела
Например:
	Init();  // Инициализация программы


6.5. Комментарий области видимости - эта одна либо несколько последовательных строк однострочных комментариев, описывающих содержимое области видимости (ограниченной фигурными скобками).
Такая секция комментариев визуально выделяется и подразумевается, как описание алгоритма. При этом:
- Первая либо единственная строка комментария начинается сразу же после символа '{'
- Следующие строки комментария имеют отступ, благодаря которому символы слешей "//" начинаются с той же позиции, что и предыдущий комментарий.
Например:
	if (is_red)
	{// Если объект красный - используем уже установленный цвет фона.
	 // При этом цвет текста заменяем на белый.

		// Комментарий кода
		...
	}


6.6. Описание функции
Функции, имеющие название, которого может быть не достаточно для понимания выполняемого действия, следует описывать секцией комментариев, состоящей из следующих необязательных частей:
1. Описание того, что делает данная функция - краткое, по возможности однострочное, описание.
2. Описание смысла возвращаемого значения (по возможности - однострочное) в формате:
// Возврат: смысл_возвращаемого_значения
3. Описание параметров в формате:
// Параметры: имя_параметра_1 - назначение
//            имя_параметра_2 - назначение
//            ...
//            имя_параметра_3 - назначение
Последующие параметры выравниваются пробелами на уровень имени первого параметра (это - единственное исключение, допускающее множественные (или "длинные") пробелы)
При этом перечислять стоит только те параметры, назначение которых не очевидно, либо имеет особый смысл, в том же порядке, в котором они перечислены в объявлении функции.
Описания единственного параметра следует использовать в формате:
// Параметр: имя_параметра - назначение
После секции комментариев с описанием функции, следует поставить одну пустую строку (даже если функция - пустая)

bool Load_File(const char *file_name, int pool_index, int &error_code)
{// Загрузка очередного файла
 // Возврат: true/false - загрузили успешно / ошибка (с кодом ошибки в error_code)
 // Параметры: pool_index - индекс пула, в который нужно добавить файл
 //            error_code - Windows error code

	// Первая строка содержимого функции
}


6.7. Специальные комментарии
В случаях, когда нужно пометить код, требующий внимания позже (т.е. замеченная ошибка, недописанная функциональность) либо иные места кода, которые требуют последующего внимания,
следует комментировать в виде: //!!! Текст_комментария
Например:
void AsEngine::Increase_Life_Count()
{
	if (Life_Count < AsConfig::Max_Life_Count)
		++Life_Count;

	//!!! Отобразить на индикаторе!
}
Такие комментарии привлекают внимание при чтении и легко ищутся по коду.


6.8. // UNO
Переменные, которыми код не владеет (т.е. он не отвечает за их очистку и/или удаление), следует подписывать комментарием в виде: // UNO Опциональный_текст_комментария.
UNO - это аббревиатура от англ. "Used, Not Owned", т.е. "Используется, не принадлежит"
Например:
AXML_Reader *XML_Reader;  // UNO
Типичное применение - для хранения указателей на служебные объекты, созданные другими сущностями.
Комментарий "// UNO" следует использовать только для объявления локальных переменных и членов-данных класса, но не для параметров метода.


6.9. // No break!
В случае, когда секция case оператора switch должна продолжиться в следующей секции (т.е. не содержит оператора break, return, continue или goto), такое отсутствие перехода
следует пометить комментарием "// No break!".
Например:
switch (error_type)
{
case EError_Type::Critical:
	++Critical_Errors_Count;
	// No break!

case EError_Type::Fatal:
	++Total_Errors_Count;
	Error_List.Add(error_type, error_message);
	break
}

В случае, если секция case не содержит кода, комментарий "// No break!" не нужно указывать.
Например:
switch (card_type)
{
case ECard_Type::None:
case ECard_Type::Red:
case ECard_Type::Black:
	ASimple_Card::Draw(hdc, card_rect, card_type);
	break;
}



7. Форматирование кода

7.1. Выравнивание пробельными (пустыми) строками

7.1.1. Выравнивание в операторе switch / case.
Секции с "простым кодом" выравниваются одной пробельной строкой, т.е. в случае, когда код каждой секции case выравнен на один и тот же отступ и не содержит пробельных строк внутри,
перед каждой секцией case (кроме первой), а также перед "default:" следует ставить пробельную строку.
Во всех остальных случаях - 2 пробельных строки.
Например:
// "Простой код"
switch (value)
{
case 0:
	result = 0;
	break;

case 1:
	result = x * value;
	break;

default:
	result = y * value;
}

// Общий случай
switch (another_value)
{
case 0:
	result = 0;
	break;


case 1:
	if (x == 0)
		result = 0;
	else
		result = another_value / x;
	break;


default:
	result = -1;
}

Почему:
Двойная пробельная строка позволяет визуально выделить код каждой секции.


7.1.2. Выравнивание логических секций кода.
Логические группы кода, представленные последовательностью строк, следует разбивать на "абзацы", каждый раз используя одну пустую строку как разделитель.

В случаях, когда в одной функции реализовано несколько алгоритмов, их следует разделять двойной пробельной строкой, а так же, если это пояснит неочевидную логику,
предварить секцию однострочным комментарием.
Например:
bool AClass::Save_Log_File(const char *file_name_prefix)
{
	// 1. Создаём имя с текущей меткой времени
	...


	// 2. Создаём файл
	...


	// 3. Сохраняем лог
	...
}


7.1.3. Пробельная строка перед оператором return
Пробельная строка ставится перед оператором return, если перед ним в блоке есть более одной строки.
Например:
if (increment_one)
{
	++variable_a;
	return;  // Не ставим пробельную строку, т.к. перед return всего одна строка
}
else
{
	++variable_a;
	++variable_b;

	return;  // Ставим пробельную строку
}


7.2. Выравнивание пробелами

7.2.1. Пробелы после одинаковых скобок
Следует разделять пробелами последовательные скобки.
Группы скобок, уже использующие пробел, следует разделять последовательностью из двух пробелов.
В случаях, когда нужна большая вложенность следует кэшировать значения выражений в переменные (т.е. не использовать тройные либо ещё более длинные пробелы)
Примеры:
1. Один пробел в конце (ассиметричное разделение). Ставить пробел после открывающей скобки функции в данном случае не нужно.
Some_Function(AObj(param) )

2. Множество простых выражений в одном
if ( (symbol >= '0' && symbol <= '9') || (symbol >= 'a' && symbol <= 'z') || (symbol >= 'A' && symbol <= 'Z') )

3. Множество сложных выражений в одном
if ( ( (x + 3) * 2 > limit && y > 10)  &&  ( (x - 3) * 2 > limit && y < -10) )

Предыдущий пример лучше отрефакторить в последовательность условий (чтобы понизить сложность одной строки):
if ( (x + 3) * 2 > limit && y > 10)
	if ( (x - 3) * 2 > limit && y < -10)


7.2.2. Выравнивание кода и данных
Для отступов следует использовать только символы табуляции.
Не следует выравнивать данные и значения дополнительными пробелами - всегда используйте один пробел за исключением случаев использования двойных пробелов для одинаковых скобок
(это правило не относится к содержимому комментариев, текст в которых можно выравнивать любым удобным способом).
Например, вместо такого кода:
Some_Function("first value",                      EValue_Type::Int,                15);
Some_Function("second value",                     EValue_Type::Unsigned_Long_Long, 18);
Some_Function("last optimal and rare used value", EValue_Type::String,             "ok");

Следует написать так:
Some_Function("first value", EValue_Type::Int, 15);
Some_Function("second value", EValue_Type::Unsigned_Long_Long, 18);
Some_Function("last optimal and rare used value", EValue_Type::String, "ok");

Почему:
1. "Стихи", красиво разреженные пробелами или табуляцией занимают много места и их сложно редактировать, т.к. они имеют пробелы разного размера
1.1. Однако, чтение так отформатированного кода происходит быстрее, но это - единственное преимущество
2. При добавлении/удалении кода с таким разреженным форматированием иногда приходится подправлять все остальные строки, чтобы сохранить выравнивание
3. Обычно в результате множества изменений в разных редакторах в течение жизни проекта, такие разреженные строки расползаются и теряют выравнивание, т.к. не все программисты
   достаточно дисциплинированны.


7.3. Фигурные скобки
Открывающая скобка:
1. Может следовать после идентификатора в той же строке только если закрывающая скобка находится в той же строке (т.е. "короткое объявление")
2. Во всех остальных случаях всегда находится на следующей строке (т.е. никогда не является последним символом).
Например:
class AClass
{
public:
	AClass() : X(0), Y(0) {};  // "Короткое объявление"

	void Some_Method();

private:
	int X, Y;
};

void AClass::Some_Method()
{
}

Для секции кода, состоящей из одной строки, фигурные скобки не используются, т.к. это экономит 2 строки кода, что повышает читабельность.

В случаях, когда однострочная секция кода сама имеет под-секции, фигурные скобки не ставятся только для однострочных секций.
Например:
1. Все секции - однострочные
for (i = 0; i < height; i++)
	for (j = 0; j < width; j++)
		if (field[i][j] != 0)
			field[i][j]->Update();

2. Не все секции однострочные - оператор if имеет оператор else и, таким образом, имеет 2 секции
for (y = 0; y < height; y++)
	for (x = 0; x < width; x++)
	{
		if (field[y][x].Is_Active() )
			field[y][x]->Show();
		else
			field[y][x]->Hide();
	}


7.4. Обращение к членам объекта
Не использовать пробел перед и после точки либо стрелки при обращении к члену данных объекта. Например:
rectangle.X = 10;
line->Draw();


7.5. Завершающие пробелы
Не оставлять в конце строк пробелов и символов табуляции
Последней строкой любого файла (*.cpp или *.h) должна быть пустая строка.


7.6. Один пробел как разделитель
Для разделения имён и символов всегда использовать один пробел (кроме особого случая двойных пробелов для одинаковых скобок).
Все операторы (кроме унарных) должны разделяться одним пробелом с соседними значениями.
Например:
int x = a + b * c - d / 3 - i++;

Для повышения читабельности для отрицательного условия после оператора ! ставится пробел. Например:
if (! condition)
	Do_Something();

Пробелами разделяются символы фигурных скобок от своего содержимого. Например:
int array[3] = { 1, 2, 3 };


7.7. Перенос длинных условий
Если строка условия слишком длинная (не помещается в экран), её можно перенести на следующую строку так, чтобы очередной условный оператор был в начале. Например:

if ( (symbol >= '0' && symbol <= '1')  ||  (symbol >= 'a' && symbol <= 'z')  ||  (symbol >= 'A' && symbol <= 'Z')
   ||  (symbol >= 'а' && symbol <= 'я')  ||  (symbol >= 'А' && symbol <= 'Я')  ||  symbol == 'ё'  ||  symbol == 'Ё')
	return true;


7.8. Код в строке с case
В секции case оператора switch не следует размещать код в строке, содержащей case. Например:
switch (value)
{
   case 1: Some_Action(); break;  // Плохой вариант
   case 2: break;  // Плохой вариант

	// Правильный вариант:
   case 3:
		break;

	// Правильный вариант:
   case 4:
		Some_Action();
		break;
}


7.9. Размещение else и if
Ключевое слово else должен размещаться на отдельной строке от своего парного if. Однако, использование else if в одной строке, для начала вложенного условия - допустимо.
Например:
1. Плохие варианты:
if (condition) Do_Something();

if (condition) Do_Something(); else Do_Nothing();

if (condition)
   Do_Something();
else Do_Nothing();

2. Правильные варианты:

if (condition)
   Do_Something();
else
   Do_Nothing();

if (condition_1)
   Action_1();
else if (condition_2)
   Action_2();
else
   Action_3();


7.10. Скобки для оператора return
Не использовать скобки для оператора return. Например:
return (value);  // Плохо
return value;  // Правильно


7.11. & и *
Символы & и * являются частью имени, а не типа. Например:
int a, &b, *c;  // Правильно
int& d;  // Плохо
int* e;  // Плохо  



8. Типы

8.1. Стандартные типы
Не следует использовать типы данных из <stdint.h>, такие, как int32_t, int_least8_t, int_fast64_t и пр.
Эти синонимы засоряют код, увеличивая количество сущностей, которые должен помнить программист.
И, хотя в C++ размер целых типов может быть разным в разных архитектурах (например, int может трактоваться как 64-разрядное целое), на практике такие системы встретить
невероятно сложно. В случае использования нестандартной архитектуры используйте другой кодстайл, использующий стандартную библиотеку.
Мы всегда подразумеваем, что наш код будет работать на системах со стандартным размером встроенных типов.
Для встроенных типов следует всегда использовать только следующие типы С++: 
для 8-битных целых - char и unsigned char
для 16-битных целых - short и unsigned short,
для 32-битных целых - int и unsigned int,
для 64-битных целых - long long и unsigned long long,
для 32-битных вещественных - float,
для 64-битных вещественных - double,
для 80-битных вещественных - long double


8.2. RTTI (Run-Time Type Information)
Не использовать RTTI, по возможности - отключать его поддержку в коде.
Не следует использовать код, проверяющий тип объекта - вместо этого следует пользоваться механизмом виртуальных функций.


8.3. Преобразования типов
Для преобразования всегда использовать только круглые скобки. Например:
int a = (int)12.3f;
AOne_Type *one_type = (AOne_Type *)another_type.
Применяя преобразования типов мы всегда исходим из предположений, что:
1. Нам известны оба типа - исходный и целевой.
2. Мы преобразовываем либо встроенные типы ко встроенным, либо типы внутри одной иерархии
Не использовать операторы кастинга:
- dynamic_cast, т.к. мы не ожидаем получить тип вне иерархии, а так же можем не иметь информации RTTI
- static_cast, т.к. он эквивалентен круглым скобкам и, следовательно, не нужен
- const_cast, т.к. он предназначен для снятия константности с константного элемента; при необходимости использовать const_cast следует изменить архитектуру так, чтобы эта необходимость отпала
- reinterpret_cast, т.к. он эквивалентен круглым скобкам и, следовательно, не нужен

Обязательно полное описание условия в if - никаких неявных преобразований в bool. Например:
int a = 0;
if (! a)
	Do_Something();  // Плохо!

if (a == 0)
	Do_Something();  // Правильно


8.4. Оператор преобразования типа
Никогда не использовать оператор преобразования типа - никаких неявных преобразований, только явные!
Почему:
1. При чтении кода невозможно понять, используется оператор преобразования типа или нет.
2. Использование оператора преобразования типа может выглядеть как ошибка, особенно при чтении кода в сторонних инструментах (мердж файлов или код-ревью).


8.5. auto
Использовать только как тип итератора в операторе range-based for, и только в случаях, когда итерирование производится по контейнерам стандартной библиотеки.
Во всех остальных случаях тип auto - не использовать, т.к. читая код невозможно понять, какой тип маскирует auto.


8.6. Алиасинг типов
Не следует использовать typedef и using для назначения дополнительного имени типу.
Почему:
1. Это увеличивает количество имён сущностей, которыми должен оперировать программист, что усложняет программу
2. Затрудняет рефакторинг кода, т.к. вместо одного типа придётся оперировать множеством его синонимов
3. Необходимость сокрытия длинного имени под коротким является сигналом о том, что необходимо изменить архитектуру так, чтобы упростить длинное имя.


8.7. Перечисления (enum)
Для перечислений следует использовать enum class с указанием размера константы. Например:
enum class EDirection_Type: usigned char
{
	Forward,
	Left,
	Right
};
При этом для констант не следует использовать префиксы, т.к. константы определяются внутри своего типа перечисления.
Использование простого enum допускается как временная мера, требующая последующего рефакторинга.
Почему: константы в простом enum размещаются о общем пространстве имён и по этой причине одинаковые имена могут пересекаться в разных типах.


8.8. Использование указателей в контейнерах.
Следует во всех контейнерах хранить только указатели на объекты, но не экземпляры. Это снимает множество проблем и соответствующих архитектурных изменений, необходимых для
оперирования множеством экземпляров объектов.
Использование экземпляров допускается, то только если хранение данных в таком виде имеет преимущество перед указателями для решения текущей задачи.



9. Инициализация данных

9.1. Инициализация переменных встроенного типа - только присваиванием.


9.2. Инициализация переменных сложного типа - только в круглых скобках (во избежания лишней инициализации при использовании оператора присваивания). Например:
1. Плохой вариант - множество способов инициализации объектов:
AOne_Class object_1 = 15;
AAnother_Class object_1 = { 3, 4 };

2. Правильный вариант - единообразная инициализация объектов
AOne_Class object_2(15);  // Правильно
AAnother_Class object_1(3, 4);  // Правильно


9.3. Инициализация фигурными скобками
Используется только для массивов, а также посторонних структур и классов, не имеющих соответствующего конструктора. Для сущностей проекта всегда нужно создавать конструкторы
и избегать использования фигурных скобок для инициализации.
Не используется для встроенных типов (чтобы инициализация встроенных и сложных типов отличалась визуально).


9.4. Инициализация указателя
При инициализации указателя нулём или сравнении указателя с нулевым значением следует использовать 0, а не nullptr или предопределённые константы вроде NULL.
Например:
float *ptr = 0;
if (ptr == 0)  // Правильно
	Do_Something();

if (ptr == nullptr)  // Не правильно!
	Do_Something();

Почему:
1. Нулевой указатель всегда содержит 0, использовать константу NULL, равную 0, не имеет смысла, т.к. она всегда будет равна 0.
2. nullptr всего лишь увеличивает объём кода и вводит новую (лишнюю) сущность.
3. Редкий случай, когда nullptr помогает разрешить перегрузку функций, свидетельствует о плохом архитектурном решении, которое следует исправить:

void Function(int param);
void Function(int *param);

Function(0);  // Будет вызвана Function(int param)

Запрет на использование nullptr вынудит программиста искать другое решение в данном случае.


9.5. Инициализация всех не-статических членов данных встроенного типа (либо отображённых на встроенный тип) должна быть выполнена в списке инициализации конструктора, при этом:
- Указатели на новые объекты в куче инициализируются дважды - первый раз нулём в списке инициализации, второй - адресом в памяти при создании объекта (в конструкторе либо другом методе)
- Игнорируем возможность инициализации в описании класса


9.6. Перенос длинной строки списка инициализации конструктора
Если строка списка инициализации конструктора слишком длинная (не помещается в экран), её можно перенести на следующую строку.



10. Проверка значений

10.1. Проверка булевых значений
Для булевых значений - всегда проверять значение, а не сравнивать с true или false.
Например:
bool is_red = true;
if (is_red)  // Правильно
	Do_Something();

if (is_red == false)  // Не правильно!
	Do_Something();


10.2. Проверка всех остальных типов
Для всех остальных типов - всегда явно проверять условие.
int *a = 0;
if (a)  // Не правильно!
	Do_Something();

if (a != 0)  // Правильно
	Do_Something();


10.3. Двойное отрицание
Не использовать двойное отрицание для преобразования значения в булево.
int *ptr = 0;
if (!!ptr)  // Не правильно!
	Do_Something();

if (ptr != 0)  // Правильно
	Do_Something();


10.4. Возврат отсутствия объекта
Отсутствие объекта следует указывать возвратом false вместо возврата нулевого указателя.
Пример 1 - понадобится лишняя строка кода на присваивание переменной либо сложный синтаксис:
AObject *Get_Object()
{
	return 0;
}

AObject *obj_1;

obj_1 = Get_Object();  // Лишняя строка

if (obj_1 != 0)
	Do_Something();

if (AObject *obj_1 = Get_Object() )  // Сложный синтаксис; объявление переменной не в начале функции
	Do_Something(obj_1);


Пример 2 - экономим одну строку кода, можем использовать переменную obj_2 после вызова функции Get_Object():
bool Get_Object(AObject **obj)
{
	return false;
}

AObject *obj_2;

if (Get_Object(&obj_2) )
	Do_Something(obj_2);


10.5. Тернарное условие
Не использовать тернарный оператор условия (?). Единственное, где без этого очень сложно обойтись - макросы, а мы макросы не используем.
Почему:
1. Такие условия нечитаемы, их нужно анализировать.
2. Вложенные тернарные условия особо дороги в сопровождении


10.6. Развёрнутые условия вместо компактных. Такой код:
if (x < max_x && y < max_y)
	return true;
else
	return false;

лучше такого:
return (x < max_x && y < max_y);

Почему: развёрнутый код бегло читается, в то время как для вычисления значения компактного понадобится отладчик в этой точке, либо анализ кода



11. Особенности C++

11.1. Использование this
Если с this и без this код работает одинаково - не использовать this (т.е. обычно не используется).
Не использовать this для обращения к членам класса.


11.2. Оператор goto
Оператор goto следует применять:
1. В функциях, имеющих множество точек выхода
2. Когда нужно выполнить одинаковую последовательность действий в нескольких точках кода
3. Для прерывания циклов.

bool AClass::Example(int param_1, int param_2)
{
	if (param_1 < 0 || param_1 >= Max_Value)
		goto _error_exit;

	if (param_2 == 3 || param_2 >= 15)
		goto _error_exit;

	Do_Cool_Stuff(param_1);
	Do_Something_Else(param_2);

	return true;

_error_exit:
	Log_Error("Can't perform example for", param_1, param_2);
	Make_Some_Finalization();

	return false;
}

Не использовать goto для организации циклов.


11.3. Макросы
Единственное допустимое применение - для условной компиляции, во всех остальных случаях - недопустимо.
Почему: значение, определённое в одном месте может быть переопределено в другом и в момент использования нет гарантии, что макрос имеет определённое значение.

Следует избегать "динамического" построения кода, когда идентификаторы создаются посредством обращения к макросу.
Почему:
1. Простой поиск по коду может не найти такой производный символ.
2. Среда разработки может не определить значение и/или расположение определения динамического символа во время отладки

Альтернатива макросам: статические методы и шаблоны.


11.4. Исключения
Не использовать исключения для возврата параметров либо как альтернативу выходу из программы.
Использовать исключения только в двух ситуациях:
1. Для отладки, чтобы привлечь внимание программиста. В таком случае, не следует создавать класс исключения, достаточно бросать целое число, например:
throw 13;
Ещё лучшим вариантом будет вызов статической функции, которая внутри бросает исключение. Например:
void Throw()
{
	throw 13;  // Закомментировать эту строку для отключения исключений
}

2. Для аварийного завершения программы, когда дальнейшее выполнение не приемлемо. В таком случае, исключение должно быть перехвачено и обработано в самой программе для
корректного завершения работы.


11.5. Шаблоны
Шаблонные классы и методы можно применять, но следует ограничиться простым использованием, игнорируя сложные паттерны.
Если есть альтернативное решение без шаблонов, либо с менее сложным применением шаблонов, которое в сопровождении займёт меньше времени - следует избрать его.



12. Особенности новых стандартов (C++11 и старше)

12.1. Использование нововведений в C++
Следует избегать использования всех нововведений в C++, начиная с C++11 и старше, за исключением auto, range-based for и enum class.


12.2. range-based for
Использовать только для контейнеров стандартной библиотеки. Для итерирования по другим коллекциям - использовать обычные циклы (for или while).


12.3. constexpr
Не использовать constexpr, т.к. это может маскировать нетривиальную логику, а так же усложняет чтение кода.
В случаях, когда нужно выполнить нетривиальный алгоритм для получения константного выражения, такой код следует выполнять явно, вызывая соответствующие функции.


12.4. Лямбды
Не использовать лямбда-функции.
Почему:
1. Лямбда-функции нечитаемы, их нужно анализировать, что затрудняет чтение кода
2. Лямбда-функции имеют нетривиальный синтаксис и особенности использования, требующие от программиста дополнительных знаний
3. Лямбда-функции нарушают инкапсуляцию класса, т.к. не являются его членом (и в общем случае ведут себя как глобальные функции)
4. Лямбда-функции нельзя повторно использовать, и в результате сопровождения кода, когда нужно продублировать решение, использующее лямбды, возникают копии лямбда-функций.
5. Лямбда-функции сложно отлаживать, т.к. традиционно лямбды, имеющие множество строк кода, пишут в одну строку, и отладчик выполняет её целиком, не позволяя пройти
   по шагам (для отладки таких лямбд нужно остановить проект, разбить функцию на строки и перезапустить программу, что крайне неэффективно)
Альтернатива лямбда-функции:
1. Статический метод класса
2. Рефакторинг архитектуры с целью найти другое решение, в котором лямбда-функция не понадобится.



13. Использование стандартной библиотеки

13.1. Стандартные потоки
Не следует использовать стандартные потоки (std::cin, std::cout, std::cerr и std::clog), а также ввод-вывод операторами << и >>.
Почему:
1. Код может быть задействован в подсистеме, не использующей стандартный ввод/вывод
2. Неудобный функционал по форматированию строки, по сравнению с printf() или собственной реализацией
3. Необходимость перегрузки операторов << и >> для классов, осуществляющих ввод/вывод


13.2. Контейнеры стандартной библиотеки
Можно использовать, если в проекте нет своих контейнеров. В случаях, когда для операций с контейнерами требуется дополнительная функциональность, следует создать свои контейнеры,
основанные на стандартных (агрегацией, но не наследованием).
Во избежание последующего рефакторинга, для проекта стоит создать свои контейнеры.


13.3. Алгоритмы стандартной библиотеки
По возможности, избегать использования алгоритмов стандартной библиотеки, т.к. они нарушают инкапсуляцию сущностей, содержащихся в контейнерах, а так же требуют от программиста
знания этих алгоритмов.
Т.к. метод (стандартный алгоритм), оперирующий объектом, находится за пределами объекта, и в общем случае является глобальным, то это и нарушает инкапсуляцию объекта.
Альтернативой алгоритмам могут быть:
- в случае общих для всех объектов методов, например, сортировки - методы контейнера (инкапсуляция алгоритма в контейнере)
- для методов, специфичных для объекта - метод объекта (инкапсуляция алгоритма в объекте)
В любом случае, контейнер и его коллекцию операций следует инкапсулировать в соответствующий класс для того, чтобы при дальнейшем сопровождении кода использовать такой класс,
снижая сложность кода за счёт инкапсуляции алгоритмов в соответствующую сущность. Другими словами, следует свести выбор программиста к ограниченному набору методов своего класса,
вместо широкого набора стандартных алгоритмов.

Например:
template <class Type> class AList
{
public:
	...
	void Sort();  // Инкапсуляция алгоритма в контейнере
	...
}

int i;
AList<My_Class *> list;

for (i = 0; i < list.Count(); i++)
	list[i]->Calculate();  // Инкапсуляция алгоритма в объекте (альтернатива for_each для функции Calculate() )



14. Прочие правила

14.1. Традиционные паттерны
Следует избегать использования общеизвестных паттернов "Банды четырёх" - синглтона, фасада, декоратора и всех остальных.
Если в результате решения задачи получится результат, похожий на такой паттерн - это хороший и приемлемый результат, однако ни в коем случае нельзя подгонять решаемую
задачу под один из таких паттернов.
Почему:
1. Большинство паттернов являются общими решениями неких общих задач, и обычно не подходят для решения конкретных задач
2. Паттерны могут оперировать сущностями, зависимостями и механиками, которых может не быть в проекте. Попытка добавить такие "посторонние" элементы в проект может исказить решение.
3. Паттерны, как правило, сложны в реализации и дороги в поддержке.


14.2. Умные указатели
По возможности, НЕ использовать умные указатели (smart pointers).
Следует избегать ситуаций, когда, удаляя объект, мы предполагаем, что этот объект ещё где-либо используется.
Вместо модели архитектуры, в которой множество сущностей могут удалить один разделяемый (shared) ресурс, следует использовать модель, в которой за удаление экземпляра разделяемого
ресурса всегда отвечает один объект.
Для указателя на объект следует всегда использовать обычный указатель.


14.3. Сторонние библиотеки
1. По возможности, не использовать стандартную библиотеку (std) явно. Алгоритмы и контейнеры стандартной библиотеки следует инкапсулировать в собственные классы проекта.
2. Не использовать boost, т.к. этот инструмент требует экспертного уровня знаний от всех программистов, сопровождающих проект.
3. Не использовать WTL(ATL), если можно обойтись стандартной библиотекой.


14.4. Ассерты
Не следует использовать ассерты, т.к. они содержат код, который не компилируется в релизной сборке.
Использование ассертов приводит к тому, что код и поведение программы в отладочном и релизном коде отличается, что не правильно, т.к. отлаживать следует код,
который поставляется потом в релизе.
Традиционно ассерты содержат код для трейсинга программы, т.е. являются альтернативой логированию. В таком случае, вместо ассертов лучше использовать логирование.


14.5. Сериализация
Для сериализации следует использовать алгоритм, но не отображать данные на плоскую структуру данных (POD-тип).
Отображение данных на структуру следует использовать только если алгоритмическая сериализация не решает поставленную задачу.
Почему:
1. Изменение структуры, отображаемой на данные, может принести в проект множество проблем, а т.к. изменение структуры может быть неявным (например, изменение выравнивания
   полей при изменениях настроек компилятора), то такое решение привносит в проект риск нестабильности.
2. Различные версии сериализации для одной и той же сущности при использовании алгоритма можно поддерживать в одном классе, в то время, как для отображения понадобится отдельный
   класс (структура) на каждую версию.
